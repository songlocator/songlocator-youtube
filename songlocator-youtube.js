//@ sourceMappingURL=songlocator-youtube.map
// Generated by CoffeeScript 1.6.1
/*

  SongLocator resolver for YouTube.

  2013 (c) Andrey Popp <8mayday@gmail.com>

  Based on Tomahawk YouTube resolver.

  2012 (C) Hugo Lindström <hugolm84@gmail.com>
  2012 (C) Thierry Göckel <thierry@strayrayday.lu>
  2012 (C) Leo Franchi <lfranchi@kde.org>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

(function(root, factory) {
  var SongLocator;
  if (typeof exports === 'object') {
    SongLocator = require('songlocator-base');
    return module.exports = factory(SongLocator);
  } else if (typeof define === 'function' && define.amd) {
    return define(function(require) {
      SongLocator = require('songlocator-base');
      return root.SongLocator.YouTube = factory(SongLocator);
    });
  } else {
    return root.SongLocator.YouTube = factory(SongLocator);
  }
})(this, function(_arg) {
  var BaseResolver, Resolver, extend, regexIndexOf;
  BaseResolver = _arg.BaseResolver, extend = _arg.extend;
  regexIndexOf = function(s, regex, startpos) {
    var indexOf;
    indexOf = s.substring(startpos || 0).search(regex);
    if (indexOf >= 0) {
      return indexOf + (startpos || 0);
    } else {
      return indexOf;
    }
  };
  Resolver = (function(_super) {

    __extends(Resolver, _super);

    function Resolver() {
      return Resolver.__super__.constructor.apply(this, arguments);
    }

    Resolver.prototype.name = 'youtube';

    Resolver.prototype.search = function(qid, query) {
      var params, url,
        _this = this;
      url = 'http://gdata.youtube.com/feeds/api/videos/';
      params = {
        alt: 'jsonc',
        q: query,
        'max-results': this.options.searchMaxResults,
        v: 2
      };
      return this.request({
        url: url,
        params: params,
        callback: function(error, response) {
          var item, result, results;
          if (error) {
            return;
          }
          if (response.data.totalItems === 0) {
            return;
          }
          results = (function() {
            var _i, _len, _ref, _results;
            _ref = response.data.items;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              result = this.item2result(item, query);
              if (result == null) {
                continue;
              }
              _results.push(result);
            }
            return _results;
          }).call(_this);
          return _this.results(qid, results);
        }
      });
    };

    Resolver.prototype.resolve = function(qid, title, artist, album) {
      var query;
      query = [artist || '', title || ''].join(' ').trim();
      return this.search(qid, query);
    };

    Resolver.prototype.item2result = function(item, query) {
      var parsedTrack, _ref, _ref1;
      if (!(item.title && item.duration && !item.contentRating)) {
        return;
      }
      if (!this.dirtyCheckTitle(item.title, query)) {
        return;
      }
      parsedTrack = this.cleanupAndParseTrack(item.title, query);
      if (!parsedTrack || (parsedTrack.artist == null)) {
        return;
      }
      if (!this.getTrack(item.title, query, true)) {
        return;
      }
      return {
        title: parsedTrack.track,
        artist: parsedTrack.artist,
        album: void 0,
        source: this.name,
        id: item.id,
        linkURL: item.player['default'] + '&hd=1',
        imageURL: ((_ref = item.thumbnail) != null ? _ref.hqDefault : void 0) || ((_ref1 = item.thumbnail) != null ? _ref1.sqDefault : void 0),
        audioURL: void 0,
        audioPreviewURL: void 0,
        mimetype: "video/h264",
        duration: item.duration
      };
    };

    Resolver.prototype.dirtyCheckTitle = function(title, query) {
      var matches, queryItem, titleItem;
      titleItem = title.replace(/([^A-Za-z0-9\s])/gi, "").replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, '').replace(/\s+/g, '|');
      queryItem = query.replace(/([^A-Za-z0-9\s])/gi, "").replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, '').replace(/\s+/g, '|');
      matches = titleItem.match(RegExp(queryItem, 'gi'));
      return matches && matches.length === queryItem.split("|").length;
    };

    Resolver.prototype.cleanupAndParseTrack = function(title, query) {
      var inQuote, replaceWith, result, tryMatch;
      result = {};
      if (regexIndexOf(title, /(?:[([](?=(official))).*?(?:[)\]])|(?:(official|video)).*?(?:(video))/i, 0) !== -1) {
        title = title.replace(/(?:[([](?=(official|video))).*?(?:[)\]])/gi, "");
        title = title.replace(/(official|video(?:([!:-])))/gi, "");
        result.isOfficial = 1;
      }
      result.query = title;
      inQuote = title.match(/([""'])(?:(?=(\\?))\2.).*\1/g);
      if (inQuote && inQuote !== void 0) {
        result.track = inQuote[0].substr(1, inQuote[0].length - 2);
        title = title.replace(inQuote[0], '');
        result.fromQuote = result.track;
        result.parsed = this.parseCleanTrack(title);
        if (result.parsed) {
          result.parsed.track = result.track;
          return result.parsed;
        }
      } else {
        result.parsed = this.parseCleanTrack(title);
        if (result.parsed) {
          return result.parsed;
        }
      }
      if (!result.parsed) {
        if (title.toLowerCase().indexOf(query.toLowerCase()) !== -1) {
          result.parsed = this.parseCleanTrack(title.replace(RegExp(query, "gi"), query.concat(" :")));
        } else {
          tryMatch = query.replace(/(?:[-|:&])/g, " ");
          if (title.toLowerCase().indexOf(tryMatch.toLowerCase()) !== -1) {
            replaceWith = regexIndexOf(title, /(?:[-|:&])/g, 0) !== -1 ? query : query.concat(" : ");
            result.parsed = this.parseCleanTrack(title.replace(RegExp(tryMatch, "gi"), replaceWith));
          }
        }
      }
      if (result.fromQuote && result.fromQuote !== void 0) {
        if (result.parsed) {
          result.artist = result.parsed.artist;
        }
        result.track = result.fromQuote;
      } else if (result.parsed) {
        if (result.parsed.artist !== void 0) {
          result.artist = result.parsed.artist;
        }
        if (result.parsed.track !== void 0) {
          result.track = result.parsed.track;
        }
      }
      delete result.parsed;
      return result;
    };

    Resolver.prototype.parseCleanTrack = function(track) {
      var ftmatch, result;
      result = {};
      result.query = track;
      result.query.replace(/.*?(?=([-:|]\s))/g, function(param) {
        if (param !== "") {
          if (result.artist === void 0) {
            return result.artist = param;
          } else {
            if (result.track === void 0) {
              return result.track = param;
            }
          }
        }
      });
      result.query.replace(/(?=([-:|]\s)).*/g, function(param) {
        if (param !== "") {
          if (regexIndexOf(param, /([-|:]\s)/g, 0) === 0) {
            if (result.track === void 0) {
              return result.track = param.replace(/([-|:]\s)/g, "");
            }
          } else {
            if (tyresult.artist === void 0) {
              result.artist = param;
            }
            return result.track = result.replace(/([-|:]\s)/g, "");
          }
        }
      });
      if (result.track !== void 0 && result.artist !== void 0) {
        ftmatch = result.artist.match(/(?:(\s)(?=(feat.|feat|ft.|ft|featuring)(?=(\s)))).*/gi);
        if (ftmatch) {
          result.artist = result.artist.replace(ftmatch, "");
          result.track += " " + ftmatch;
        }
        result.track = result.track.replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, '').replace(/\s+/g, ' ');
        result.artist = result.artist.replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, '').replace(/\s+/g, ' ');
        return result;
      }
    };

    Resolver.prototype.getTrack = function(trackTitle, origTitle, isSearch) {
      if ((this.options.includeCovers === false || this.options.includeCovers === void 0) && trackTitle.search(/(\Wcover(?!(\w)))/i) !== -1 && origTitle.search(/(\Wcover(?!(\w)))/i) === -1) {
        return;
      }
      if (isSearch === void 0) {
        if ((this.options.includeRemixes === false || this.options.includeRemixes === void 0) && trackTitle.search(/(\W(re)*?mix(?!(\w)))/i) !== -1 && origTitle.search(/(\W(re)*?mix(?!(\w)))/i) === -1) {
          return;
        }
      }
      if ((this.options.includeLive === false || this.options.includeLive === void 0) && trackTitle.search(/(live(?!(\w)))/i) !== -1 && origTitle.search(/(live(?!(\w)))/i) === -1) {

      } else {
        return trackTitle;
      }
    };

    return Resolver;

  })(BaseResolver);
  return {
    Resolver: Resolver
  };
});
